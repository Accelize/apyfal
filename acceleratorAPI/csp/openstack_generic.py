# coding=utf-8
"""OpenStack based CSP"""

import openstack as _openstack
import keystoneauth1.exceptions.http as _keystoneauth_exceptions

from acceleratorAPI import logger
from acceleratorAPI import _utilities as _utl
import acceleratorAPI.csp as _csp


class OpenStackClass(_csp.CSPGenericClass):

    def __init__(self, **kwargs):
        super(OpenStackClass, self).__init__(**kwargs)

        # Checks mandatory configuration values
        if self._project_id is None:
            raise _csp.CSPConfigurationException(
                "No 'project_id' has been specified for %s" % self._provider)

        if self._auth_url is None:
            raise _csp.CSPConfigurationException(
                "No 'auth_url' has been specified for %s" % self._provider)

        if self._interface is None:
            raise _csp.CSPConfigurationException(
                "No 'interface' has been specified for %s" % self._provider)

        # Initialize variables
        self._instance_url = None
        self._instance_type = None

        # Load session
        self._session = _openstack.connection.Connection(
            region_name=self._region,
            auth=dict(
                auth_url=self._auth_url,
                username=self._client_id,
                password=self._secret_id,
                project_id=self._project_id
            ),
            compute_api_version='2',
            identity_interface=self._interface
        )
        logger.debug("Connection object created for CSP '%s'", self._provider)

        self.check_credential()

    def check_credential(self):
        try:
            list(self._session.network.networks())
        except _keystoneauth_exceptions.Unauthorized:
            raise _csp.CSPAuthenticationException("Failed to authenticate with your CSP access key.")

    def _init_ssh_key(self):
        logger.debug("Create or check if KeyPair %s exists", self._ssh_key)

        # Get key pair from CSP
        key_pair = self._session.compute.find_keypair(self._ssh_key, ignore_missing=True)

        # Use existing key
        if key_pair:
            logger.info("KeyPair '%s' is already existing on %s.", key_pair.name, self._provider)
            return

        # Create key pair if not exists
        logger.debug("Create KeyPair '%s'", self._ssh_key)
        key_pair = self._session.compute.create_keypair(name=self._ssh_key)

        _utl.create_ssh_key_file(self._ssh_key, key_pair.private_key)

    def security_group(self):
        logger.debug("Create or check if security group '%s' exists", self._security_group)

        # Create security group if not exists
        security_group = self._session.get_security_group(self._security_group)
        if security_group is None:
            security_group = self._session.create_security_group(
                self._security_group, "Generated by accelize API", project_id=self._project_id)
            logger.info("Created security group: %s", security_group.name)

        else:
            logger.info("Security group '%s' is already existing on %s.", self._security_group, self._provider)

        # Verify rules associated to security group for host IP address
        public_ip = _utl.get_host_public_ip(logger)

        # Create rule on SSH
        try:
            self._session.create_security_group_rule(
                security_group.id, port_range_min=22, port_range_max=22, protocol="tcp", remote_ip_prefix=public_ip,
                project_id=self._project_id)

        except _openstack.exceptions.SDKException:
            pass

        # Create rule on HTTP
        try:
            self._session.create_security_group_rule(
                security_group.id, port_range_min=80, port_range_max=80, protocol="tcp", remote_ip_prefix=public_ip,
                project_id=self._project_id)
        except _openstack.exceptions.SDKException:
            pass

        logger.info("Added in security group '%s': SSH and HTTP for IP %s.", self._security_group, public_ip)

    def create_instance(self):
        self._init_ssh_key()
        self.security_group()

    def set_accelerator_requirements(self, accel_parameters):
        # Get parameters for region
        accel_parameters_in_region = self._get_region_parameters(accel_parameters)

        # Get image
        self._image_id = accel_parameters_in_region['image']
        try:
            image = self._session.compute.find_image(self._image_id)
        except _openstack.exceptions.ResourceNotFound:
            raise _csp.CSPConfigurationException(
                ("Failed to get image information for CSP '%s':\n"
                 "The image '%s' is not available on your CSP account. "
                 "Please contact Accelize.") %
                (self._provider, self._image_id))
        else:
            logger.debug("Set image '%s' with ID %s", image.name, self._image_id)

        # Get flavor
        flavor_name = accel_parameters_in_region['instancetype']
        try:
            self._instance_type = self._session.compute.find_flavor(flavor_name).id
        except _openstack.exceptions.ResourceNotFound:
            raise _csp.CSPConfigurationException(
                ("Failed to get flavor information for CSP '%s':\n"
                 "The flavor '%s' is not available in your CSP account. "
                 "Please contact you CSP to subscribe to this flavor.") %
                (self._provider, flavor_name))
        else:
            logger.debug("Set flavor '%s' with ID %s", flavor_name, self._instance_type)

    def get_configuration_env(self, **kwargs):
        return self._config_env

    def get_instance_status(self):
        if self._instance_id is None:
            raise _csp.CSPInstanceException("No instance found")

        # Try to find instance
        try:
            self._instance = self._session.get_server(self._instance_id)

        # Instance not found
        except _openstack.exceptions.SDKException as exception:
            raise _csp.CSPInstanceException(
                "Could not find an instance with ID '%s' (%s)", self._instance_id, exception)

        # Instance is alive
        else:
            logger.debug("Found an instance with ID %s in the following state: %s", self._instance_id,
                         self._instance.status)
            return self._instance.status

    def _get_instance_public_ip(self):
        if self._instance is None:
            raise _csp.CSPInstanceException("No instance found")

        for address in self._instance.addresses.values()[0]:
            if address['version'] == 4:
                return address['addr']
        raise _csp.CSPInstanceException("No instance address found")

    def wait_instance_ready(self):
        # Waiting for the instance provisioning
        logger.info("Waiting for the instance provisioning on %s...", self._provider)
        try:
            self._instance = self._session.compute.wait_for_server(self._instance)
        except _openstack.exceptions.SDKException as exception:
            raise _csp.CSPInstanceException("Instance exception: %s", exception)

        # Check instance status
        state = self._instance.status
        logger.debug("Instance status: %s", state)
        if state.lower() == "error":
            self.stop_instance()
            raise _csp.CSPInstanceException("Instance has an invalid status: %s", state)

        # Waiting for the instance to boot
        self._wait_instance_boot()

    def _start_new_instance(self):
        logger.debug("Starting instance")

        self._instance = self._session.compute.create_server(
            name=self._accelerator, image_id=self._image_id, flavor_id=self._instance_type,
            key_name=self._ssh_key, security_groups=[{"name": self._security_group}])

        self._instance_id = self._instance.id
        logger.info("Created instance ID: %s", self._instance_id)

        self.wait_instance_ready()

    def is_instance_id_valid(self):
        try:
            self.get_instance_status()
        except _csp.CSPInstanceException:
            logger.error("Could not find a instance with ID '%s' (%s)",
                         self._instance_id)
            return False
        logger.info("Using instance ID: %s", self._instance_id)
        return True

    def _start_existing_instance(self):
        state = self.get_instance_status()
        logger.debug("Status of instance ID %s: %s", self._instance_id, state)
        if state.lower() == "active":
            logger.debug("Instance ID %s is already in '%s' state.", self._instance_id, state)
            return

        self._session.start_server(self._instance)
        self.wait_instance_ready()

    def _log_instance_info(self):
        logger.info("Region: %s", self._region)
        logger.info("Public IP: %s", self._get_instance_public_ip())

    def stop_instance(self, terminate=True):
        try:
            self.get_instance_status()
        except _csp.CSPInstanceException as exception:
            logger.debug("No instance to stop (%s)", exception)
            return

        if terminate:
            if not self._session.delete_server(self._instance, wait=True):
                raise _csp.CSPInstanceException('Unable to delete instance.')
            logger.info("Instance ID %s has been terminated", self._instance_id)
        # TODO: terminate=False support, pause instance ?
